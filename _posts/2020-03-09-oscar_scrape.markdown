---
layout: post
title:      "Oscar Scrape"
date:       2020-03-09 20:00:13 +0000
permalink:  oscar_scrape
---

Coding in Ruby is such an interesting experience.  With so many different people iterating on it and adding to the program it has almost become alive.  It is now too large for any one person to know every single thing. Part of a programmers journey is learning how to look up the right answer, not simply memorizing it.  A complex organism with many creators takes a community to solve all the answers.  Its with this mindset that I start my project.  I have an introductory understanding of Ruby but I have learned how to learn.  Anything I don’t know the answer to is available with the right queries.  It’s with this that I arm myself as I start this project.
I created a program that will provide its users with the Oscar winners of last year.  It can either list out every single user, or it can return a specific winner based on the category.  The program is broken up into three classes.  The Scraper class will grab all the information from the website and manipulate it.  The OscarWinner class is the simplest.  It stores all of the information in an array to be pulled at will from the other classes.  The UI class is what the user will interact with.  It displays the text and speaks to the other classes depending on the responses from the user.
The most fun I had was creating the UI portion.  Seeing my program interact with users and using the gets.strip function was enjoyable.  Every single method had to take in account human error.  The user may not submit a correct answer, or they may submit an answer that feels correct but won’t be recognizable to the code.  So for every wrong answer the program will respond with clarification on what it needs to continue, then ask the same question again.  After playtesting it I found an error where the program would loop and loop if you didn’t put in a response it was expecting.  Thats when I had to put in else statements that would restart the method if the appropriate response wasn’t in there.  It was kind of cool anticipating user error.
I had issues with scraping the Oscar website itself though.  Everytime I would scrape the website and use .text at the end it would list not just the winner, but all the nominees.  I tried using .first.text but Ruby did not like that function.  I tried looking online for a correct answer but my problem seemed to be too specific.  The workaround I came up with was to scrape the information with .first.  It would store the winner’s name and information.  Then when I would print the name to the user I would use .text.  It felt messy but after reviewing it with my cohort leader it was the best solution.  It makes my “coding instincts” tingle but it doesn’t break the code.  If it works, it works right?
Well, no.  That’s probably wrong.  There’s code, and then there is good code.  I’m confident that what I built works really well in its bubble.  However I’m sure there is room for improvement to streamline the process.  Even though this piece works well, it may slowdown in a program that has tens of thousands of line of code.  Thats the mindset that I need to have if I refractor this code.  It can always be improved.

